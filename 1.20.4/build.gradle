plugins {
    alias libs.plugins.architecturyloom apply false
    alias libs.plugins.architecturyplugin apply false
    alias libs.plugins.shadow apply false
    alias libs.plugins.cursegradle apply false
    alias libs.plugins.minotaur apply false
}

allprojects {
    apply plugin: "architectury-plugin"
    apply plugin: "java"
    apply plugin: "java-library"
    apply plugin: "maven-publish"
    apply plugin: "signing"
    apply plugin: "idea"

    archivesBaseName = "${modName.replaceAll("[^a-zA-Z]", "")}"
    version = "v${modVersion}-${libs.versions.minecraft.get()}-${project.name}"
    group = modMavenGroup

    repositories {
        mavenCentral()
        mavenLocal()
        maven {
            name = "Sponge"
            url = "https://repo.spongepowered.org/repository/maven-public/"
        }
        maven {
            name = "Jared"
            url = "https://maven.blamejared.com/"
        }
        maven {
            name = "Jitpack"
            url = "https://jitpack.io"
        }
        maven {
            name = "Shedaniel"
            url = "https://maven.shedaniel.me/"
        }
        maven {
            name = "Parchment"
            url = "https://maven.parchmentmc.org"
        }
        maven {
            name = "Fuzs Mod Resources"
            url = "https://raw.githubusercontent.com/Fuzss/modresources/main/maven/"
        }
        maven {
            name = "Terraformers"
            url = "https://maven.terraformersmc.com/"
        }
        maven {
            name = "ModMaven"
            url = "https://modmaven.dev"
        }
        maven {
            name = "AppleSkin"
            url "https://maven.ryanliptak.com/"
        }
        flatDir {
            dirs "libs"
        }
        exclusiveContent {
            forRepository {
                maven {
                    name = "CurseForge"
                    url = "https://cursemaven.com"
                }
            }
            filter {
                includeGroup "curse.maven"
            }
        }
        exclusiveContent {
            forRepository {
                maven {
                    name = "Modrinth"
                    url = "https://api.modrinth.com/maven"
                }
            }
            filter {
                includeGroup "maven.modrinth"
            }
        }
    }

    tasks.withType(JavaCompile).configureEach {
        // ensure that the encoding is set to UTF-8, no matter what the system default is
        // this fixes some edge cases with special characters not displaying correctly
        // see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
        // If Javadoc is generated, this must be specified in that task too.
        options.encoding = 'UTF-8'
        options.release = 17
    }

    java {
        withSourcesJar()
        withJavadocJar()
        toolchain.languageVersion = JavaLanguageVersion.of(17)
    }

    // silence missing javadoc comments, we just don't care
    javadoc.options.addStringOption('Xdoclint:none', '-quiet')

    tasks.withType(Jar).configureEach {
        from rootProject.file("../LICENSE.md")
        from rootProject.file("../LICENSE-ASSETS.md")
        from rootProject.file("../LICENSE-FORGE.md")
        from rootProject.file("../LICENSE-NIGHT-CONFIG.md")
        from rootProject.file("../LICENSING.md")
        from rootProject.file("CHANGELOG.md")
        exclude "architectury.common.json"
        manifest {
            attributes([
                    "Specification-Title"           : modName,
                    'Specification-Version'         : modVersion,
                    "Specification-Vendor"          : modAuthor,
                    'Implementation-Title'          : modName,
                    'Implementation-Version'        : modVersion,
                    'Implementation-Vendor'         : modAuthor,
                    'Implementation-Timestamp'      : new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                    'Implementation-Timestamp-Milli': System.currentTimeMillis(),
                    'Implementation-URL'            : modSourceUrl,
                    'Built-On-Java'                 : "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
                    'Built-On-Minecraft'            : libs.versions.minecraft.get()
            ])
        }
        group 'jar'
    }

    tasks.withType(GenerateModuleMetadata) {
        // Disables Gradle's custom module metadata from being published to maven. The
        // metadata includes mapped dependencies which are not reasonably consumable by
        // other mod developers.
        enabled = false
    }
}

subprojects {
    apply plugin: "dev.architectury.loom"
    apply plugin: "com.github.johnrengelman.shadow"
    apply plugin: "me.hypherionmc.cursegradle"
    apply plugin: "com.modrinth.minotaur"

    loom {
        silentMojangMappingsLicense()
    }

    dependencies {
        minecraft "com.mojang:minecraft:${libs.versions.minecraft.get()}"
        mappings loom.layered() {
            it.parchment("org.parchmentmc.data:parchment-${libs.versions.parchment.minecraft.get()}:${libs.versions.parchment.version.get()}")
            it.officialMojangMappings {
                setNameSyntheticMembers(false)
            }
        }
    }

    def resourceProperties = [
            "modId": modId,
            "modName": modName,
            "modVersion": modVersion,
            "modDescription": modDescription,
            "modGroup": project.group,
            "modPageUrl": modSourceUrl,
            "modIssueUrl": modIssueUrl,
            "modAuthor": modAuthor,
            "modLicense": modLicense,
            "minFabricVersion": libs.versions.fabricloader.min.get(),
            "minFabricApiVersion": libs.versions.fabricapi.min.get(),
            "minForgeFMLVersion": libs.versions.minecraftforge.min.get().replaceAll("\\..*", ""),
            "minForgeVersion": libs.versions.minecraftforge.min.get(),
            "minNeoForgeFMLVersion": libs.versions.neoforge.min.get().replaceAll("\\..*", ""),
            "minNeoForgeVersion": libs.versions.neoforge.min.get(),
            "minecraftVersion": libs.versions.minecraft.get(),
            "minPuzzlesVersion": libs.versions.puzzleslib.min.get(),
            "resourcePackFormat": libs.versions.resources.get(),
            "dataPackFormat": libs.versions.data.get(),
            "mainEntryPoint": "${project.group}.${archivesBaseName}Fabric",
            "clientEntryPoint": "${project.group}.client.${archivesBaseName}FabricClient",
            "modFabricEnvironment": modFabricEnvironment,
            "modForgeDisplayTest": modForgeDisplayTest
    ]

    processResources {
        duplicatesStrategy DuplicatesStrategy.INCLUDE

        inputs.properties resourceProperties

        filesMatching(["pack.mcmeta", "fabric.mod.json", "META-INF/mods.toml", "architectury.common.json", modId + ".common.mixins.json", modId + ".fabric.mixins.json", modId + ".neoforge.mixins.json", modId + ".forge.mixins.json"]) {
            expand resourceProperties + [project: project]
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                artifactId = "${modId}-${project.name.toLowerCase()}"
                version = modVersion
                from components.java
                pom {
                    name = "${modName} [${project.name}]"
                    description = "${modDescription}"
                    url = "${modSourceUrl}"
                    scm {
                        url = "${modSourceUrl}"
                        connection = "${modSourceUrl}".replace("https", "scm:git:git").concat(".git")
                        developerConnection = "${modSourceUrl}".replace("https://github.com/", "scm:git:git@github.com:").concat(".git")
                    }
                    issueManagement {
                        system = 'github'
                        url = "${modIssueUrl}"
                    }
                    licenses {
                        license {
                            name = "${modLicense}"
                            url = "https://spdx.org/licenses/${modLicense}.html"
                        }
                    }
                    developers {
                        developer {
                            id = "${modAuthor}".toLowerCase()
                            name = "${modAuthor}"
                        }
                    }
                }
            }
        }
        repositories {
            maven {
                name = 'FuzsModResources'
                url "file://" + project.hasProperty('modResources') ? "${project.findProperty('modResources')}/maven" : System.getenv('local_maven')
            }
        }
    }

    signing {
        sign publishing.publications.mavenJava
    }

    curseforge {
        if (!file('../CHANGELOG.md').canRead()) {
            throw new FileNotFoundException("Could not read changelog file")
        }
        apiKey = project.hasProperty('curseApiToken') ? project.findProperty('curseApiToken') : ''
        project {
            id = projectCurseForgeId
            changelogType = 'markdown'
            changelog = file('../CHANGELOG.md')
            releaseType = projectReleaseType
            addGameVersion project.name
            addGameVersion libs.versions.minecraft.get()
            mainArtifact(remapJar) {
                displayName = "[${project.name.toUpperCase()}] [${libs.versions.minecraft.get()}] ${archivesBaseName}-v${modVersion}"
                var requiredDependencies = "dependenciesRequired${project.name}CurseForge"
                var embeddedDependencies = "dependenciesEmbedded${project.name}CurseForge"
                var optionalDependencies = "dependenciesOptional${project.name}CurseForge"
                if (project.hasProperty(requiredDependencies) || project.hasProperty(embeddedDependencies) || project.hasProperty(optionalDependencies)) {
                    relations {
                        if (project.hasProperty(requiredDependencies)) {
                            (project.findProperty(requiredDependencies) as String).split(",").each {
                                requiredDependency it.trim()
                            }
                        }
                        if (project.hasProperty(embeddedDependencies)) {
                            (project.findProperty(embeddedDependencies) as String).split(",").each {
                                embeddedLibrary it.trim()
                            }
                        }
                        if (project.hasProperty(optionalDependencies)) {
                            (project.findProperty(optionalDependencies) as String).split(",").each {
                                optionalDependency it.trim()
                            }
                        }
                    }
                }
            }
        }
        options {
//        debug = true
            javaVersionAutoDetect = false
            forgeGradleIntegration = false
        }
    }

    modrinth {
        if (!file('../CHANGELOG.md').canRead()) {
            throw new FileNotFoundException("Could not read changelog file")
        }
        token = project.hasProperty('modrinthApiToken') ? project.findProperty('modrinthApiToken') : ''
        projectId = projectModrinthId
        versionNumber = project.version
        versionName = "[${project.name.toUpperCase()}] [${libs.versions.minecraft.get()}] ${archivesBaseName}-v${modVersion}"
        changelog = file('../CHANGELOG.md').text
        versionType = projectReleaseType
        uploadFile = remapJar
        loaders.add project.name.toLowerCase()
        gameVersions.add libs.versions.minecraft.get()
        var requiredDependencies = "dependenciesRequired${project.name}Modrinth"
        var embeddedDependencies = "dependenciesEmbedded${project.name}Modrinth"
        var optionalDependencies = "dependenciesOptional${project.name}Modrinth"
        if (project.hasProperty(requiredDependencies) || project.hasProperty(embeddedDependencies) || project.hasProperty(optionalDependencies)) {
            dependencies {
                if (project.hasProperty(requiredDependencies)) {
                    (project.findProperty(requiredDependencies) as String).split(",").each {
                        required.project it.trim()
                    }
                }
                if (project.hasProperty(embeddedDependencies)) {
                    (project.findProperty(embeddedDependencies) as String).split(",").each {
                        embedded.project it.trim()
                    }
                }
                if (project.hasProperty(optionalDependencies)) {
                    (project.findProperty(optionalDependencies) as String).split(",").each {
                        optional.project it.trim()
                    }
                }
            }
        }
//	debugMode = true
    }

    task copyJarToDir(type: Copy) {
        onlyIf { project.hasProperty('buildJarOutputDir') && project.hasProperty('uniqueBuildNumber') }
        if (project.findProperty('copyBuildJar').toBoolean()) {
            from remapJar
            into project.findProperty('buildJarOutputDir')
            // add build number to be able to distinguish jars when testing thorough official launcher
            // build number is stored in global gradle.properties
            rename { fileName -> fileName.replace("v${modVersion}", "v${modVersion}.${uniqueBuildNumber}") }
        }
    }

    task incrementBuildNumber {
        onlyIf { project.hasProperty('uniqueBuildNumber') }
        doLast {
            var propertiesName = 'gradle.properties'
            // build number is stored in global gradle.properties
            var propertiesFile = new File(project.gradle.gradleUserHomeDir, propertiesName)
            if (!propertiesFile.canRead()) { throw new FileNotFoundException("Could not read file ".concat(propertiesName)) }
            var buildNumberMatcher = java.util.regex.Pattern.compile("uniqueBuildNumber=(\\d+)").matcher(propertiesFile.getText())
            buildNumberMatcher.find()
            var versionCode = Integer.parseInt(buildNumberMatcher.group(1))
            var propertiesContent = buildNumberMatcher.replaceAll("uniqueBuildNumber=" + ++versionCode)
            propertiesFile.write(propertiesContent)
        }
    }

    build.finalizedBy project.tasks.copyJarToDir, project.tasks.incrementBuildNumber
}

apply from: './gradle/tasks.gradle'

println('Java: ' + System.getProperty('java.version') + ' JVM: ' + System.getProperty('java.vm.version') + '(' + System.getProperty('java.vendor') + ') Arch: ' + System.getProperty('os.arch'))

architectury {
    minecraft = libs.versions.minecraft.get()
}
